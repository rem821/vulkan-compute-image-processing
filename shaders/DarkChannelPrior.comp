#version 450

#define GROUP_SIZE 32

layout (local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE) in;

layout (binding = 0, rgba8) uniform readonly image2D inputImage;
layout (binding = 1, rgba8) uniform image2D resultImage;
layout (binding = 2) buffer AirLightBuffer {
    int groups[][3];
} airLightData;
layout(binding = 3) uniform UBO {
    vec3 airLight;
    float omega;
} uboComputeShader;

const int kernelSize = 8;

struct ImageData
{
    float pixels[kernelSize * kernelSize];
} kernelMinChannels;

shared float[GROUP_SIZE][GROUP_SIZE][3] groupAirLights;

void main()
{
    if(uboComputeShader.airLight.x > 0) return;
    // Fetch neighbouring texels
    int n = 0;
    for (int i = -kernelSize / 2; i <= kernelSize / 2; ++i)
    {
        for (int j = -kernelSize / 2; j <= kernelSize / 2; ++j)
        {
            vec3 rgb = imageLoad(inputImage, ivec2(gl_GlobalInvocationID.x + i, gl_GlobalInvocationID.y + j)).rgb;

            kernelMinChannels.pixels[n] = min(min(rgb.r, rgb.g), rgb.b);
            n++;
        }
    }

    float kernelMin = 1.0;
    for (int l = 0; l < n; ++l) {
        if (kernelMinChannels.pixels[l] < kernelMin) {
            kernelMin = kernelMinChannels.pixels[l];
        }
    }

    vec4 res = vec4(kernelMin, kernelMin, kernelMin, 1.0);

    // Only For Debug Purposes
    //vec4 res = vec4(gl_WorkGroupID.x / 32.0, gl_WorkGroupID.y / 32.0, 0.0, 1.0);
    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), res);


    vec3 rgb = imageLoad(inputImage, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y)).rgb;
    groupAirLights[gl_LocalInvocationID.x][gl_LocalInvocationID.y][0] = rgb.r * 255;
    groupAirLights[gl_LocalInvocationID.x][gl_LocalInvocationID.y][1] = rgb.g * 255;
    groupAirLights[gl_LocalInvocationID.x][gl_LocalInvocationID.y][2] = rgb.b * 255;

    groupMemoryBarrier();
    if (!(gl_LocalInvocationID.x == 0 && gl_LocalInvocationID.y == 0)) {
        return;
    }

    float[3] brightestPixel = {0.0f, 0.0f, 0.0f};
    for (int z = 0; z < 3; ++z) {
        for (int y = 0; y < GROUP_SIZE; ++y) {
            for (int x = 0; x < GROUP_SIZE; ++x) {
                if (groupAirLights[x][y][z] > brightestPixel[z]) {
                    brightestPixel[z] = groupAirLights[x][y][z];
                }
            }
        }
    }

    // Only For Debug Purposes
    //airLightData.groups[gl_WorkGroupID.x + gl_NumWorkGroups.x * gl_WorkGroupID.y][0] = int(0);
    //airLightData.groups[gl_WorkGroupID.x + gl_NumWorkGroups.x * gl_WorkGroupID.y][1] = int(100);
    //airLightData.groups[gl_WorkGroupID.x + gl_NumWorkGroups.x * gl_WorkGroupID.y][2] = int(200);

    airLightData.groups[gl_WorkGroupID.x + gl_NumWorkGroups.x * gl_WorkGroupID.y][0] = int(brightestPixel[0]);
    airLightData.groups[gl_WorkGroupID.x + gl_NumWorkGroups.x * gl_WorkGroupID.y][1] = int(brightestPixel[1]);
    airLightData.groups[gl_WorkGroupID.x + gl_NumWorkGroups.x * gl_WorkGroupID.y][2] = int(brightestPixel[2]);
}